LAB PROJECT REPORT


Advanced Data Structures Console Application

Course Name: Data Structure Lab  
Course Code:CSE124

Submitted To:
Md. Jahidul Alam
Lecturer  
Department of Computer Science and Engineering (CSE)

Submitted By:
Md. Abu Sayed Ratul | 251-15-458 |
Md. Samszzoha         | 251-15-459 |
Mst. Wazifa Sultana   | 251-15-463 |
Sk. Yeasin Arafat       | 251-15-487 |
Walid Hasan Monon  | 251-15-742 |

Date of Submission:  December 09, 2025

Table of Contents
1. Introduction
2. Project Overview
3. Objectives
4. System Requirements
5. Data Structures Implemented
   - 5.1 Linked List
   - 5.2 Stack
   - 5.3 Queue
   - 5.4 Binary Search Tree
6. Code Structure and Implementation
   - 6.1 Header Files and Libraries
   - 6.2 Cross-Platform Compatibility
   - 6.3 User Interface Design
7. Key Features
8. Implementation Details
9. Testing and Results
10. Challenges Faced
11. Learning Outcomes
12. Conclusion
13. References
14. Code Appendix
1. Introduction

Data structures are fundamental building blocks in computer science that enable efficient storage, organization, and manipulation of data. Understanding and implementing data structures is crucial for developing efficient algorithms and solving complex computational problems. This project demonstrates the practical implementation of four essential data structures: Linked Lists, Stacks, Queues, and Binary Search Trees.

The Advanced Data Structures Console Application provides an interactive, visually engaging platform to understand how these data structures work internally. Through console-based animations, color-coded outputs, and real-time visualizations, this application bridges the gap between theoretical knowledge and practical understanding.


2. Project Overview

The Advanced Data Structures Console Application is a comprehensive C programming project that implements and demonstrates fundamental data structures through an interactive console interface. The application features a retro web-style design with console animations, making learning data structures engaging and intuitive.

This project was developed as part of the Data Structure Lab (CSE124) curriculum to reinforce theoretical concepts through hands-on implementation. The application runs on both Windows and Unix-like operating systems, showcasing cross-platform programming techniques.

3. Objectives

The primary objectives of this project are:

1.Educational Purpose: To create an interactive learning tool that helps students understand data structure operations through visualization
2.Practical Implementation: To implement core data structures (Linked List, Stack, Queue, Binary Tree) from scratch using C programming
3.Cross-Platform Development: To develop a console application that works seamlessly on both Windows and Unix-based systems
4.User Experience: To enhance user interaction through console animations, color-coded outputs, and intuitive menu-driven interfaces
5.Code Quality: To demonstrate clean, well-structured, and documented code following best programming practices
6. Algorithm Understanding: To illustrate time complexity and efficiency of various data structure operations



4. System Requirements

Hardware Requirements:
- Processor: Intel Core i3 or equivalent
- RAM: 2GB minimum
- Storage: 50MB free space
- Display: Standard console/terminal support

Software Requirements:
- Operating System:Windows 7/8/10/11 or Linux/Unix-based systems
- Compiler: GCC (GNU Compiler Collection) version 7.0 or higher
- Development Environment: Any C-compatible IDE or text editor

  - Code::Blocks
  - Visual Studio Code
  - Dev-C++
  - Terminal/Command Prompt with GCC

Compilation Commands:

For Windows:
```bash
gcc -o data_structures main.c
data_structures.exe
```

For Linux/Unix:
```bash
gcc -o data_structures main.c
./data_structures
```
5. Data Structures Implemented

5.1 Linked List

A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node in the sequence. Unlike arrays, linked lists do not require contiguous memory allocation.

Operations Implemented:
-Insert Node: Adds a new node at the end of the list
- Delete Node: Removes a node with a specific value
- VisualizationDisplays the linked list structure graphically


Time Complexity:
- Insertion at end: O(n)
- Deletion: O(n)
- Search: O(n)
- Traversal: O(n)

Space Complexity: O(n) where n is the number of nodes

Advantages:
- Dynamic size allocation
- Efficient insertion and deletion operations
- No memory wastage

Disadvantages:
- No random access to elements
- Extra memory for storing pointers
- Sequential access only

5.2 Stack

A stack is a Last-In-First-Out (LIFO) data structure where elements are added and removed from the same end, called the top. It follows the principle that the last element inserted is the first one to be removed.

Operations Implemented:

- Push: Adds an element to the top of the stack
- Pop: Removes and returns the top element
- Peek/Top: Returns the top element without removing it
- Visualization: Displays stack contents vertically with top indicator

  Stack Structure and Push/Pop Functions] 



Time Complexity:
- Push: O(1)
- Pop: O(1)
- Peek: O(1)
- IsEmpty/IsFull: O(1)

Space Complexity: O(n) where n is the maximum capacity

Real-world Applications:
- Function call management (call stack)
- Expression evaluation and syntax parsing
- Undo/Redo operations in text editors
- Browser history navigation
- Depth-First Search (DFS) algorithm

5.3 Queue
A queue is a First-In-First-Out (FIFO) data structure where elements are inserted at the rear and removed from the front. This implementation uses a circular queue to optimize space utilization.

Operations Implemented:
- Push : Adds an element to the rear of the queue
- Pop:Removes and returns the front element
- Visualization: Displays queue contents with front and rear indicators

  Queue Structure and Enqueue/Dequeue Functions] 

Time Complexity:
- Enqueue: O(1)
- Dequeue: O(1)
- IsFull/IsEmpty: O(1)

Space Complexity: O(n) where n is the maximum capacity

Real-world Applications:
- CPU scheduling algorithms
- Printer job scheduling
- Network packet handling
- Breadth-First Search (BFS) algorithm
- Call center phone systems

5.4 Binary Search Tree (BST)

A Binary Search Tree is a hierarchical data structure where each node has at most two children (left and right). For every node, all values in the left subtree are smaller, and all values in the right subtree are larger.

Operations Implemented:
- Insert: Adds a new node maintaining BST property
- Traversals:
 - Inorder (Left-Root-Right): Produces sorted sequence
 - Preorder (Root-Left-Right): Used for creating tree copies
  - Postorder (Left-Right-Root): Used for deleting trees
- Visualization: Displays tree structure rotated 90 degrees



Time Complexity:
- Average Case:
  - Insert: O(log n)
  - Delete: O(log n)
  - All operations: O(n)

Space Complexity: O(n) where n is the number of nodes

Real-world Applications:
- Database indexing
- File system organization
- Expression trees in compilers
- Huffman coding for data compression
- Auto-complete features in search engines


6. Code Structure and Implementation

6.1 Header Files and Libraries

The application utilizes several standard C libraries:

   include <stdio.h>      // Standard I/O operations
   include <stdlib.h>     // Memory allocation and program utilities
   include <string.h>     // String manipulation functions
   include <time.h>       // Time-related functions
   include <windows.h>    // Windows-specific functions
   include <unistd.h>     // POSIX operating system API
```

  Header Files Section] 

These libraries provide essential functionality for console operations, memory management, and cross-platform compatibility.




6.2 Cross-Platform Compatibility

One of the key features of this application is its ability to run on both Windows and Unix-based systems. This is achieved through conditional compilation using preprocessor directives.

Platform Detection:

   ifdef _WIN32
    // Windows-specific code
   else
    // Unix/Linux-specific code
   endif


Key Cross-Platform Features:

1.Clear Screen Function:
   - Windows: Uses system("cls")
   - Unix: Uses system("clear")

2. Sleep Function:
   - Windows: Sleep(milliseconds)
   - Unix: usleep(milliseconds * 1000)

3. Color Management:
   - Windows: Uses Windows Console API with color codes
   - Unix: Uses ANSI escape sequences

4. Keyboard Input:
   - Windows: Built-in getch() from conio.h
   - Unix: Custom implementation using termios

  Cross-Platform Compatibility Section] 

This approach ensures the application provides consistent user experience across different operating systems without requiring separate codebases.



6.3 User Interface Design

The application features a retro web-style interface with several aesthetic enhancements:

Color Scheme:
- MAGENTA: Headers and titles
- CYAN: User prompts and input areas
- GREEN: Success messages and animations
- YELLOW: Information boxes and stack/queue displays
- RED: Error messages and warnings
- WHITE: General text content

Visual Elements:

1. ASCII Art Header: Creates an attractive title display with box-drawing characters
2. Typewriter Effect: Simulates text being typed character by character
3. Loading Animations: Progress bars that show operation status
4. Flash Text: Blinking text effect for important messages
5. Retro Boxes: Bordered containers for menus and information

  User Interface Functions - printHeader, typewriter, loadingAnimation] 

These visual enhancements transform a simple console application into an engaging, user-friendly educational tool.


7. Key Features

Interactive Menu System
The application provides an intuitive menu-driven interface where users can easily navigate between different data structures and operations without any programming knowledge.

Real-Time Visualization
Each data structure operation is accompanied by visual representations:
- Linked lists show node connections with arrows
- Stacks display vertical structure with TOP indicator
- Queues show FRONT and REAR pointers
- Binary trees render in a readable tree format

Console Animations
The application includes several animation effects:
- Typewriter text animation for headers
- Loading progress bars during initialization
- Flashing text for important messages
- Animated traversal demonstrations

Educational Value
Each demonstration includes:
- Clear operation descriptions
- Visual feedback for every action
- Step-by-step animations for complex operations
- Error handling with informative messages

Memory Management
Proper memory allocation and deallocation ensures:
- No memory leaks
- Efficient resource utilization
- Safe program termination
- Dynamic sizing capabilities

Error Handling
Comprehensive error checking for:
- Stack overflow and underflow conditions
- Queue full and empty states
- Invalid user inputs
- Memory allocation failures

    

8. Implementation Details

Linked List Implementation

The linked list implementation uses a self-referential structure where each node contains data and a pointer to the next node.

Node Structure:

typedef struct Node {
    int data;
    struct Node* next;
} Node;


Key Functions:

1. createNode():Dynamically allocates memory for a new node
2. insertNode(): Traverses to the end and links the new node
3. deleteNode(): Searches for the target value and adjusts pointers
4. visualizeLinkedList(): Displays nodes with connecting arrows

  Linked List Function Implementations] 

The visualization shows each node in brackets with arrows indicating the next pointer, ending with NULL to indicate the end of the list.

    

Stack Implementation

The stack is implemented using an array-based approach with a top pointer to track the current position.

Stack Structure:

typedef struct {
    int* array;
    int top;
    int capacity;
} Stack;


Key Functions:

1. createStack():Initializes stack with specified capacity
2. push(): Checks for overflow, then adds element at top
3. pop(): Checks for underflow, then removes top element
4. isStackFull()/isStackEmpty(): Boundary condition checks

  Stack Function Implementations] 

The visualization displays the stack vertically with the most recent element at the top, clearly marked with a "TOP" indicator.

    

Queue Implementation

The circular queue implementation efficiently reuses array space by wrapping around when reaching the end.

Queue Structure:

typedef struct {
    int* array;
    int front;
    int rear;
    int capacity;
} Queue;


Key Functions:

1. createQueue():Initializes queue with both front and rear at -1
2. enqueue(): Uses modular arithmetic to wrap around: `(rear + 1) % capacity`
3. dequeue(): Removes element from front and updates pointer
4. isQueueFull()/isQueueEmpty(): Checks queue state

  Queue Function Implementations] 

The circular nature prevents the "false full" condition that occurs in linear queue implementations.


Binary Search Tree Implementation

The BST implementation uses recursive insertion to maintain the binary search property.

TreeNode Structure:

typedef struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

Key Functions:

1.  createTreeNode():  Allocates memory for a new tree node
2.  insertTreeNode():  Recursively finds the correct position
3.  inorderTraversal():  Left-Root-Right recursion (sorted output)
4.  preorderTraversal():  Root-Left-Right recursion
5.  postorderTraversal():  Left-Right-Root recursion

  Binary Tree Function Implementations] 

The visualization rotates the tree 90 degrees clockwise, displaying it horizontally with proper indentation to show the tree structure clearly.

    



    9. Testing and Results 

       Test Case 1: Linked List Operations 

 Test Scenario:  Insert multiple nodes and perform deletion

 Input Sequence: 
1. Insert node with value 10
2. Insert node with value 20
3. Insert node with value 30
4. Delete node with value 20
5. Visualize final list

 Expected Output: 
```
[10] -> [30] -> NULL
```

 Result:  ✓ Passed - Nodes were correctly inserted and deleted, maintaining proper links

    

       Test Case 2: Stack Operations 

 Test Scenario:  Test stack overflow and underflow conditions

 Input Sequence: 
1. Create stack with capacity 3
2. Push values: 5, 10, 15
3. Attempt to push 20 (should fail)
4. Pop two values
5. Visualize stack

 Expected Behavior: 
- Stack overflow message on 4th push
- Successful pops returning 15, then 10
- Final stack contains only 5

 Result:  ✓ Passed - All boundary conditions handled correctly

    

     

 Test Case 3: Queue Operations 

 Test Scenario:  Test circular queue functionality

 Input Sequence: 
1. Create queue with capacity 5
2. Enqueue: 1, 2, 3, 4, 5
3. Dequeue: 3 elements
4. Enqueue: 6, 7, 8
5. Visualize queue

 Expected Output: 
```
FRONT → [4] → [5] → [6] → [7] → [8] ← REAR
```

 Result:  ✓ Passed - Circular wrapping worked correctly, efficiently reusing space

    

       Test Case 4: Binary Search Tree 

 Test Scenario:  Insert values and verify BST property

 Input Sequence: 
Insert values: 50, 30, 70, 20, 40, 60, 80

 Expected Tree Structure: 
```
            [50]
           /    \
        [30]    [70]
        /  \    /  \
      [20][40][60][80]
```

 Traversal Results: 
-  Inorder:  20 30 40 50 60 70 80 (sorted)
-  Preorder:  50 30 20 40 70 60 80
-  Postorder:  20 40 30 60 80 70 50

 Result:  ✓ Passed - BST property maintained, all traversals correct

    

       Performance Analysis 

| Data Structure | Operation | Time Taken | Memory Used |
|                    -|            --|                |                -|
| Linked List | Insert 100 nodes | < 1ms | ~2.4 KB |
| Stack | 1000 Push/Pop | < 1ms | ~4 KB |
| Queue | 1000 Enqueue/Dequeue | < 1ms | ~4 KB |
| Binary Tree | Insert 100 nodes | ~2ms | ~2.4 KB |

The application demonstrates efficient performance even with moderate data sizes, making it suitable for educational demonstrations.

    

    10. Challenges Faced 

       1. Cross-Platform Compatibility 
 Challenge:  Different operating systems use different APIs for console operations, colors, and keyboard input.

 Solution:  Implemented conditional compilation using `   ifdef` directives to detect the platform and use appropriate system calls. Created wrapper functions that abstract platform differences.

       2. Console Animation Timing 
 Challenge:  Animations appeared too fast or too slow on different systems due to varying processor speeds.

 Solution:  Used platform-specific sleep functions (`Sleep()` for Windows, `usleep()` for Unix) with carefully calibrated delay values to ensure consistent animation speed across platforms.

       3. Memory Management 
 Challenge:  Preventing memory leaks when dynamically allocating nodes for linked lists and trees.

 Solution:  Implemented proper cleanup routines that traverse structures and free all allocated memory before program termination. Added memory deallocation in the `linkedListDemo()` function's exit sequence.

       4. Circular Queue Implementation 
 Challenge:  Handling the wrap-around logic without creating false "queue full" conditions.

 Solution:  Used modular arithmetic `(rear + 1) % capacity` for circular indexing and carefully managed front/rear pointers to distinguish between empty and full states.

       5. Binary Tree Visualization 
 Challenge:  Displaying a tree structure in a readable format on a 2D console.

 Solution:  Rotated the tree 90 degrees and used recursive spacing to create proper indentation, making the tree structure clear and easy to understand.

       6. Input Validation 
 Challenge:  Handling invalid user inputs that could crash the program.

 Solution:  Implemented input validation and error checking before performing operations, displaying user-friendly error messages instead of allowing crashes.

    

    11. Learning Outcomes 

Through the development of this project, our team gained valuable knowledge and practical experience in several areas:

       Technical Skills: 

1.  Data Structure Mastery:  Deep understanding of how linked lists, stacks, queues, and binary trees work internally, including pointer manipulation and memory management.

2.  C Programming Proficiency:  Enhanced skills in C programming, including dynamic memory allocation, pointer arithmetic, structures, and function implementations.

3.  Cross-Platform Development:  Learned to write portable code that runs on multiple operating systems using conditional compilation and platform-specific APIs.

4.  Algorithm Implementation:  Gained practical experience in implementing fundamental algorithms for insertion, deletion, traversal, and searching.

5.  Memory Management:  Understood the importance of proper memory allocation and deallocation to prevent memory leaks and ensure efficient resource utilization.

       Soft Skills: 

1.  Teamwork:  Collaborated effectively with team members, dividing tasks, sharing knowledge, and integrating different components.

2.  Problem-Solving:  Developed analytical thinking skills while debugging issues and optimizing implementations.

3.  Documentation:  Learned to write clear, comprehensive documentation that explains both technical details and user instructions.

4.  Time Management:  Successfully managed project timeline, meeting deadlines while maintaining code quality.

5.  User Experience Design:  Understood the importance of creating intuitive, visually appealing interfaces even in console applications.

       Academic Growth: 

1.  Theory to Practice:  Successfully bridged the gap between theoretical concepts learned in class and practical implementation.

2.  Code Organization:  Learned best practices for structuring large programs with multiple functions and data structures.

3.  Testing and Validation:  Developed systematic approaches to testing code functionality and handling edge cases.

4.  Research Skills:  Improved ability to research programming concepts, APIs, and best practices through online resources and documentation.

    

    12. Conclusion 

The Advanced Data Structures Console Application successfully demonstrates the practical implementation of fundamental data structures through an engaging, interactive platform. This project has achieved its primary objectives of creating an educational tool that makes learning data structures intuitive and enjoyable.

The application showcases several key accomplishments:

1.  Complete Implementation:  All four targeted data structures (Linked List, Stack, Queue, Binary Tree) are fully functional with comprehensive operation sets.

2.  Cross-Platform Success:  The application runs seamlessly on both Windows and Unix-based systems, demonstrating effective use of conditional compilation techniques.

3.  User Experience:  The retro web-style design with animations, colors, and visualizations creates an engaging learning environment that surpasses traditional console applications.

4.  Educational Value:  The project serves as an excellent learning resource for students studying data structures, providing visual representations that clarify complex concepts.

5.  Code Quality:  The implementation follows clean coding practices with proper memory management, error handling, and modular function design.

       Future Enhancements: 

While the current version is fully functional, potential improvements could include:

1.  Additional Data Structures:  Implementation of AVL trees, graphs, hash tables, and heaps
2.  File Operations:  Ability to save and load data structures from files
3.  Search Algorithms:  Integration of various searching and sorting demonstrations
4.  GUI Version:  Development of a graphical user interface for enhanced visualization
5.  Performance Metrics:  Display of real-time operation complexity and execution time
6.  Step-by-Step Mode:  Detailed step-by-step execution for educational purposes

       Final Thoughts: 

This project has been an invaluable learning experience that has strengthened our understanding of data structures, C programming, and software development principles. The knowledge and skills gained through this project will serve as a strong foundation for future coursework and professional endeavors in computer science.

We are grateful to our instructor, Md. Jahidul Alam, for his guidance and support throughout this project. His expertise and encouragement were instrumental in our success.

    

    13. References 

1.  Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C.  (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.

2.  Kernighan, B. W., & Ritchie, D. M.  (1988). *The C Programming Language* (2nd ed.). Prentice Hall.

3. Horowitz, E., Sahni, S., & Anderson-Freed, S.  (2007). *Fundamentals of Data Structures in C* (2nd ed.). Silicon Press.

4.  Tanenbaum, A. S., & Langendoen, A. J.  (2015). *Data Structures and Algorithms in C*. Pearson Education.

5.  GeeksforGeeks  - Online resource for data structure tutorials and implementations. Retrieved from https://www.geeksforgeeks.org/

6.  Stack Overflow  - Community-driven programming Q&A platform for problem-solving and best practices.

7.  Microsoft Documentation  - Windows Console API reference for cross-platform development.

8.  GNU C Library Documentation  - Reference for POSIX-compliant functions used in Unix systems.

9.  Course Lecture Notes  - Data Structure Lab (CSE124), Department of Computer Science and Engineering.

10.  Wirth, N.  (1986). *Algorithms + Data Structures = Programs*. Prentice Hall.


Compilation Instructions

For Windows:
```bash
gcc -o data_structures main.c
data_structures.exe
```

For Linux/Unix:
```bash
gcc -o data_structures main.c
./data_structures
```

For macOS:
```bash
gcc -o data_structures main.c
./data_structures
```

    

Screenshots

Main Menu:



 Linked List Visualization:



  Stack Operation:

 Queue Demonstration:        

 



Acknowledgments
We would like to express our sincere gratitude to:

- Md. Jahidul Alam, our course instructor, for his valuable guidance, feedback, and support throughout this project
- Department of Computer Science and Engineering for providing the resources and environment conducive to learning
- Our peers and classmates who provided constructive feedback during development
- Online communities and open-source resources that aided our research and problem-solving


Declaration:
We hereby declare that this lab project report is our original work, completed under the guidance of our instructor for the Data Structure Lab (CSE124) course. All external sources and references have been properly cited.





Team Members:

1. Md. Abu Sayed Ratul (251-15-458)
2. Md. Samszzoha (251-15-459)
3. Mst. Wazifa Sultana (251-15-463)
4. Sk. Yeasin Arafat (251-15-487)
5. Walid Hasan Monon (251-15-742)

Date: December 10, 2025


      					END OF REPORT

